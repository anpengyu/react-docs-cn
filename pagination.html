<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <!-- Basic -->
    <title>分页 | Apollo React 中文文档</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="images/favicon.png" sizes="16x16 32x32 64x64">

    <!-- Social -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://apollographqlcn.github.io/react-docs-cn">
    <meta property="og:title" content="分页 | Apollo React 中文文档">
    <meta property="og:description" content="">
    <meta property="og:image" content="">
    <meta name="twitter:card" content="summary_image_large">
    <meta name="twitter:site" content="@apollographqlcn">
    <meta name="twitter:title" content="分页 | Apollo React 中文文档">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="">

    <!-- Misc -->
    <meta name="google-site-verification" content="" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,200,300italic,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/react-docs-cn/style/style.css">
  </head>
  <body class="">
    

<div class="nav dark">
  <div class="nav-group">
    <div class="nav-item show-mobile">
      <span class="js-sidebar-toggle ">
        <span class="icon-menu"></span>
      </span>
    </div>
    <div class="nav-item">
      
      <a class="logo-wrapper" href="http://dev.apollodata.com/" title="Apollo Developers"  >
        <img src="images/logo-apollo-space-left.svg" alt="Apollo" class="logo"/><img src="images/logo-apollo-subbrands-developers-space.svg" class="logo-subbrand" alt="Developers"/>
      </a>
    </div>
  </div>

  <div class="nav-group right">
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="https://apollographqlcn.github.io/react-docs-cn/"  >
          <span>React</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="http://dev.apollodata.com/angular2"  >
          <span>Angular</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="http://dev.apollodata.com/ios"  >
          <span>iOS</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="http://dev.apollodata.com/android"  >
          <span>Android</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="http://dev.apollodata.com/core"  >
          <span>Vanilla JS</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false separator">
        <a class="link" href="http://dev.apollodata.com/tools"  >
          <span>Server</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="https://medium.com/apollo-stack" target=_new >
          <span>Blog</span>
        </a>
      </div>
    
      
      <div class="nav-item show-desktop false ">
        <a class="link" href="http://dev.apollodata.com/community"  >
          <span>Community</span>
        </a>
      </div>
    
  </div>
</div>

<div class="sidebar">
  <div class="panel">
    <div class="panel-item">
      <a class="" href="http:/dev.apollodata.com/" title="Apollo"  >
        <span>Apollo Developers</span>
      </a>
    </div>
    
      <div class="panel-item "">
        <a class="" href="https://apollographqlcn.github.io/react-docs-cn/"  >
          <span>React</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://dev.apollodata.com/angular2"  >
          <span>Angular</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://dev.apollodata.com/ios"  >
          <span>iOS</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://dev.apollodata.com/android"  >
          <span>Android</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://dev.apollodata.com/core"  >
          <span>Vanilla JS</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://dev.apollodata.com/tools"  >
          <span>Server</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="https://medium.com/apollo-stack" target=_new >
          <span>Blog</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://dev.apollodata.com/community"  >
          <span>Community</span>
        </a>
      </div>
    
  </div>

  <div class="sidebar-content">
    <div class="topcap">
      <span class="title-sidebar">Apollo React 中文文档</span>
      
    </div>

    

    <ul class="toc">
      
        <li>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="index.html" class="sidebar-link ">
                  <span>简介</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="initialization.html" class="sidebar-link ">
                  <span>安装和配置</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="simple-example.html" class="sidebar-link ">
                  <span>简易示例：Snack</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="example-schema.html" class="sidebar-link ">
                  <span>完整示例：GitHunt</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="migration.html" class="sidebar-link ">
                  <span>迁移到1.0</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">使用</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="queries.html" class="sidebar-link ">
                  <span>查询</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="mutations.html" class="sidebar-link ">
                  <span>突变</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="subscriptions.html" class="sidebar-link ">
                  <span>订阅</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="receiving-updates.html" class="sidebar-link ">
                  <span>同步服务端数据</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="cache-updates.html" class="sidebar-link ">
                  <span>更新 Store</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-with-types.html" class="sidebar-link ">
                  <span>使用 TypeScript 和 Flow</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">API 参考</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="api.html" class="sidebar-link ">
                  <span>综合</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="api-graphql.html" class="sidebar-link ">
                  <span>graphql: 容器</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="api-queries.html" class="sidebar-link ">
                  <span>graphql: 查询</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="api-mutations.html" class="sidebar-link ">
                  <span>graphql: 突变</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="api-server.html" class="sidebar-link ">
                  <span>服务端渲染</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">技巧</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="auth.html" class="sidebar-link ">
                  <span>认证</span>
                </a>
              </li>
            
              
              <li class="item-toc  current">
                <a href="" class="sidebar-link  current">
                  <span>分页</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="optimistic-ui.html" class="sidebar-link ">
                  <span>乐观 UI</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="fragments.html" class="sidebar-link ">
                  <span>使用片段</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="prefetching.html" class="sidebar-link ">
                  <span>预取数据</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="query-splitting.html" class="sidebar-link ">
                  <span>查询分割</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="react-native.html" class="sidebar-link ">
                  <span>与 React Native 集成</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="redux.html" class="sidebar-link ">
                  <span>与 Redux 集成</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="webpack.html" class="sidebar-link ">
                  <span>Webpack 加载器</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="server-side-rendering.html" class="sidebar-link ">
                  <span>服务端渲染</span>
                </a>
              </li>
            
          </ul>
        </li>
      
    </ul>
  </div>
</div>

<div class="content">
  <div class="content-wrapper">
    <div class="header-content">
      <h1 class="title-page">分页</h1>
      

      <div class="page-actions">
        <div class="actions-group">
          <a class="btn tertiary small round lowercase" href="https://github.com/apollographqlcn/react-docs-cn/tree/master/source/pagination.md" target="_blank"><span class="icon-github"></span> <span>在 GitHub 上编辑本文</span></a>
          
        </div>
      </div>
    </div>

    <div class="document-formatting">
      <p>通常，在你的应用中有些视图，显示的列表需要包含太多数据，而无法一次性获取或显示。分页是解决该问题的最常见的方案，Apollo 客户端通过内置的功能，使其变得非常简单。</p>
<p>获取分页数据基本上有两种方法：编号页面和游标。还有两种显示分页数据的方法：离散页面和无限滚动。如果想更深入地了解它们的不同之处，以及各自的使用场景，建议你阅读我们撰写的关于该主题的博文：<a href="https://medium.com/apollo-stack/understanding-pagination-rest-graphql-and-relay-b10f835549e7" target="_blank" rel="external">了解分页</a>。</p>
<p>在本文中，我们将介绍使用 Apollo 实现这两种分页方法的技术细节。</p>
<h2 id="fetch-more">使用 <code>fetchMore</code></h2>

<p>在Apollo中，最简单的分页方法是使用一个叫做 <a href="cache-updates.html#fetchMore"><code>fetchMore</code></a> 的函数，它由 <code>graphql</code> 高阶组件的 <code>data</code> prop 提供，它基本上允许你执行一个新的 GraphQL 查询并将结果合并到原始结果中。</p>
<p>你可以指定要用于新查询的查询和变量，以及如何将新查询结果与客户端上的现有数据进行合并。你的设置将决定你会实现哪种分页。</p>
<h2 id="numbered-pages">基于偏移量</h2>

<p>基于偏移量的分页 - 也称为编号页面 - 是一种在许多网站上非常常见的模式，因为通常是后端最容易实现的方式。例如，在 SQL 中，使用 <a href="https://www.postgresql.org/docs/8.2/static/queries-limit.html" target="_blank" rel="external">OFFSET 和 LIMIT</a> 可以很容易地生成编号页面。</p>
<p>以下是从 <a href="https://github.com/apollographql/GitHunt-React" target="_blank" rel="external">GitHunt</a> 获取的编号页面的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> FEED_QUERY = gql<span class="string">`</span></div><div class="line">  query Feed($type: FeedType!, $offset: Int, $limit: Int) &#123;</div><div class="line">    currentUser &#123;</div><div class="line">      login</div><div class="line">    &#125;</div><div class="line">    feed(type: $type, offset: $offset, limit: $limit) &#123;</div><div class="line">      id</div><div class="line">      # ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ITEMS_PER_PAGE = <span class="number">10</span>;</div><div class="line"><span class="keyword">const</span> FeedWithData = graphql(FEED_QUERY, &#123;</div><div class="line">  options(props) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">variables</span>: &#123;</div><div class="line">        <span class="attr">type</span>: (</div><div class="line">          props.params &amp;&amp;</div><div class="line">          props.params.type &amp;&amp;</div><div class="line">          props.params.type.toUpperCase()</div><div class="line">        ) || <span class="string">'TOP'</span>,</div><div class="line">        <span class="attr">offset</span>: <span class="number">0</span>,</div><div class="line">        <span class="attr">limit</span>: ITEMS_PER_PAGE,</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">fetchPolicy</span>: <span class="string">'network-only'</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  props(&#123; <span class="attr">data</span>: &#123; loading, feed, currentUser, fetchMore &#125; &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      loading,</div><div class="line">      feed,</div><div class="line">      currentUser,</div><div class="line">      loadMoreEntries() &#123;</div><div class="line">        <span class="keyword">return</span> fetchMore(&#123;</div><div class="line">          <span class="comment">// 查询： ...（你可以指定一个不同的查询，默认情况下使用 FEED_QUERY）</span></div><div class="line">          variables: &#123;</div><div class="line">            <span class="comment">// 我们可以指定偏移量的值，因为它与 feed 长度相匹配，但是我们也可以使用状态或者先前的变量来计算（参见下面的游标示例）</span></div><div class="line">            offset: feed.length,</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">updateQuery</span>: <span class="function">(<span class="params">previousResult, &#123; fetchMoreResult &#125;</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!fetchMoreResult) &#123; <span class="keyword">return</span> previousResult; &#125;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, previousResult, &#123;</div><div class="line">              <span class="comment">// 将新的 feed 结果追加到旧的 feed 结果</span></div><div class="line">              feed: [...previousResult.feed, ...fetchMoreResult.feed],</div><div class="line">            &#125;);</div><div class="line">          &#125;,</div><div class="line">        &#125;);</div><div class="line">      &#125;,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">&#125;)(Feed);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/apollographql/GitHunt-React/blob/c0b18795a18b3da42dc90cf7c63b29b14965206d/ui/Feed.js#L165" target="_blank" rel="external">在 GitHunt 的提交中查看这段代码。</a></p>
<p>你可以看到，<code>fetchMore</code> 可以通过 <code>props</code> 函数的 <code>data</code> 参数访问到。所以我们的演示组件可以不用知道 Apollo，我们使用 <code>props</code> 定义一个简单的 “load more” 函数，名为 <code>loadMoreEntries</code>，可以由子组件 <code>Feed</code> 调用。这样，如果我们需要改变分页逻辑，我们就不需要改变 <code>Feed</code> 组件了。</p>
<p>在上面的例子中，<code>loadMoreEntries</code> 是一个函数，它调用 <code>fetchMore</code>，把当前 feed 的长度作为一个变量。默认情况下，<code>fetchMore</code> 更多会使用原来的 <code>query</code>，所以我们只是传入新的变量。一旦从服务器返回新数据，<code>updateQuery</code> 函数用于将它与现有数据进行合并，这将导致你的 UI 组件使用扩展后的列表重新渲染。</p>
<p>下面的代码展示了如何从 UI 组件调用 <code>loadMoreEntries</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Feed = <span class="function">(<span class="params">&#123; vote, loading, currentUser, feed, loadMoreEntries &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">FeedContent</span></span></div><div class="line">        <span class="attr">entries</span>=<span class="string">&#123;feed</span> || []&#125;</div><div class="line">        <span class="attr">currentUser</span>=<span class="string">&#123;currentUser&#125;</span></div><div class="line">        <span class="attr">onVote</span>=<span class="string">&#123;vote&#125;</span></div><div class="line">      /&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">onClick</span>=<span class="string">&#123;loadMoreEntries&#125;</span>&gt;</span>Load more<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">      &#123;loading ? <span class="tag">&lt;<span class="name">Loading</span> /&gt;</span> : null&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法适用于限量/偏移分页。使用编号页面或偏移量的分页的一个缺点是，当某一项同时插入列表或从列表中移除时，该项可能会被跳过或返回两次。这可以通过基于游标的分页来避免。</p>
<h2 id="cursor-pages">基于游标</h2>

<p>在基于游标的分页中，使用“游标”来跟踪数据集中应该从哪获取下一组项的位置。有时候，游标可能非常简单，只是引用所获取的最后一个对象的ID，但在某些情况下，例如根据某些条件排序的列表，游标需要对排序条件进行编码以作为最后一个对象的ID的附加信息。</p>
<p>在客户端上实现基于游标的分页与基于偏移的分页没有什么不同，我们保留对所获取的最后一个对象的引用以及所使用的排序顺序的信息，而不是使用绝对偏移量。</p>
<p>在下面的示例中，我们使用 <code>fetchMore</code> 查询来连续加载新的评论，这些评论将被添加到列表前。在 <code>fetchMore</code> 查询中使用的游标由最初服务器的响应中提供，并且每当获取更多数据时都会更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MoreCommentsQuery = gql<span class="string">`</span></div><div class="line">  query MoreComments($cursor: String) &#123;</div><div class="line">    moreComments(cursor: $cursor) &#123;</div><div class="line">      cursor</div><div class="line">      comments &#123;</div><div class="line">        author</div><div class="line">        text</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> CommentsWithData = graphql(CommentsQuery, &#123;</div><div class="line">  <span class="comment">// 这个函数在每次 `data` 变化时都会重新执行，包括 `updateQuery` 之后，这意味着我们的 loadMoreEntries 函数将始终具有正确的游标</span></div><div class="line">  props(&#123; <span class="attr">data</span>: &#123; loading, cursor, comments, fetchMore &#125; &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      loading,</div><div class="line">      comments,</div><div class="line">      <span class="attr">loadMoreEntries</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> fetchMore(&#123;</div><div class="line">          <span class="attr">query</span>: MoreCommentsQuery,</div><div class="line">          <span class="attr">variables</span>: &#123;</div><div class="line">            <span class="attr">cursor</span>: cursor,</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">updateQuery</span>: <span class="function">(<span class="params">previousResult, &#123; fetchMoreResult &#125;</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">const</span> previousEntry = previousResult.entry;</div><div class="line">            <span class="keyword">const</span> newComments = fetchMoreResult.moreComments.comments;</div><div class="line">            <span class="keyword">const</span> newCursor = fetchMoreResult.moreComments.cursor;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">              <span class="comment">// 通过这里返回的 `cursor'，我们将为 `loadMore` 函数更新新的游标。</span></div><div class="line">              cursor: newCursor,</div><div class="line"></div><div class="line">              <span class="attr">entry</span>: &#123;</div><div class="line">                <span class="comment">// 将新的评论放在列表的前面</span></div><div class="line">                comments: [...newComments, ...previousEntry.comments],</div><div class="line">              &#125;,</div><div class="line">            &#125;;</div><div class="line">          &#125;,</div><div class="line">        &#125;);</div><div class="line">      &#125;,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">&#125;)(Comments);</div></pre></td></tr></table></figure>
<h2 id="relay-cursors">Relay 式的游标分页</h2>

<p>Relay 作为另一个流行的 GraphQL 客户端，对分页查询的输入和输出有专门的处理方式，所以人们有时会根据 Relay 的要求构建服务器的分页模型。如果你有一个服务器被设计为使用 <a href="https://facebook.github.io/relay/graphql/connections.htm" target="_blank" rel="external">Relay 游标连接</a> 规范，你也可以从 Apollo 客户端正常调用该服务器。</p>
<p>使用 Relay 式的游标与基于游标的基本分页非常类似。主要区别在于影响游标位置的查询响应的格式。</p>
<p>Relay 在返回的游标连接上提供了一个 <code>pageInfo</code> 对象，该对象包含的游标，分别把返回的第一个和最后一个项作为属性 <code>startCursor</code> 和 <code>endCursor</code>。此对象还包含一个布尔属性 <code>hasNextPage</code>，可用于确定是否有更多可用结果。</p>
<p>以下示例一次指定10个项的请求，并且返回的结果应开始于提供的 <code>cursor</code> 之后。如果游标的值为 <code>null</code> 则 relay 将忽略它，并从数据集开始处提供结果，该数据集允许对初始请求和后续请求使用相同的查询。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> CommentsQuery = gql<span class="string">`</span></div><div class="line">  query Comments($cursor: String) &#123;</div><div class="line">    Comments(first: 10, after: $cursor) &#123;</div><div class="line">      comments &#123;</div><div class="line">        edges &#123;</div><div class="line">          node &#123;</div><div class="line">            author</div><div class="line">            text</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        pageInfo &#123;</div><div class="line">          endCursor</div><div class="line">          hasNextPage</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> CommentsWithData = graphql(CommentsQuery, &#123;</div><div class="line">  <span class="comment">// 这个函数在每次 `data` 变化时重新运行，包括`updateQuery`之后，这意味着我们的 loadMoreEntries 函数将始终有正确的游标</span></div><div class="line">  props(&#123; <span class="attr">data</span>: &#123; loading, comments, fetchMore &#125; &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      loading,</div><div class="line">      comments,</div><div class="line">      <span class="attr">loadMoreEntries</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> fetchMore(&#123;</div><div class="line">          <span class="attr">query</span>: CommentsQuery,</div><div class="line">          <span class="attr">variables</span>: &#123;</div><div class="line">            <span class="attr">cursor</span>: comments.pageInfo.endCursor,</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">updateQuery</span>: <span class="function">(<span class="params">previousResult, &#123; fetchMoreResult &#125;</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">const</span> newEdges = fetchMoreResult.comments.edges;</div><div class="line">            <span class="keyword">const</span> pageInfo = fetchMoreResult.comments.pageInfo;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">              <span class="comment">// 将新的评论放在列表末尾并更新 `pageInfo`，这样我们就可以得到新的 `endCursor` 和 `hasNextPage` 的值</span></div><div class="line">              comments: &#123;</div><div class="line">                <span class="attr">edges</span>: [...previousResult.comments.edges, ...newEdges],</div><div class="line">                pageInfo,</div><div class="line">              &#125;,</div><div class="line">            &#125;;</div><div class="line">          &#125;,</div><div class="line">        &#125;);</div><div class="line">      &#125;,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">&#125;)(Feed);</div></pre></td></tr></table></figure>
<p></p><h2 id="connection-directive"><code>@connection</code> 指令</h2><br>当使用分页查询时，累积查询的结果可能难以在 store 中查找，因为传递给查询的参数用于标识默认的 store 键，但通常在执行查询的代码之外无法访问到。这对于命令式的 store 更新是有问题的，因为没有用于更新目标的可靠的 store 键。要引导 Apollo 客户端为分页查询使用可靠的 store 键，你可以使用可选的 <code>@ connection</code> 指令为部分查询指定 store 键。例如，如果我们想要提前提供一个可靠的 store 键，我们可以调整我们的查询以使用 <code>@connection</code> 指令：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">const</span> FEED_QUERY = gql`</div><div class="line">  query Feed(<span class="variable">$type</span>: FeedType!, <span class="variable">$offset</span>: Int, <span class="variable">$limit</span>: Int) &#123;</div><div class="line">    <span class="section">currentUser</span> &#123;</div><div class="line">      <span class="attribute">login</span></div><div class="line">    &#125;</div><div class="line">    feed(type: <span class="variable">$type</span>, offset: <span class="variable">$offset</span>, limit: <span class="variable">$limit</span>) <span class="variable">@connection</span>(key: <span class="string">"feed"</span>, filter: [<span class="string">"type"</span>]) &#123;</div><div class="line">      <span class="attribute">id</span></div><div class="line">      <span class="comment"># ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">`;</div></pre></td></tr></table></figure><p></p>
<p>这将导致每个查询或 <code>fetchMore</code> 中累积的 feed 被放置在 store 的 <code>feed</code> 键下，之后我们便可以使用命令式 store 更新。在本例中，我们还使用了 <code>@connection</code> 指令的可选 <code>filter</code> 参数，它允许我们在 store 键中加入查询的一些参数。上面的例子中，我们希望在 store 键中包含 <code>type</code> 查询参数，这样可以产生多个 store 值，它们从每种类型的 feed 页面的数据累积而来。</p>

    </div>
  </div>

  <div class="pagination">
    <div class="content-wrapper">
      
      
        <a class="link primary prev"
          href="auth.html">
          <span class="icon-arrow-left-alt"></span>
          <span class="subtitle-pagination">Previous</span>
          认证
        </a>
      
      
        <a class="link primary next"
          href="optimistic-ui.html">
          <span class="subtitle-pagination">Next</span>
          乐观 UI
          <span class="icon-arrow-right-alt"></span>
        </a>
      
    </div>
  </div>

  <div class="github">
    <a class="link tertiary " href="https://github.com/apollographqlcn/react-docs-cn/tree/master/source/pagination.md" target="_blank">
      <span class="icon-github"></span>Edit on GitHub</a>
  </div>

  
</div>

    <script src="/react-docs-cn/script/smooth-scroll.min.js"></script>
    <script src="/react-docs-cn/script/main.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

    <script>
      // nectar ninja
      (function(){
        var handle = '@meteorjs';
        var a = document.createElement('script');
        var m = document.getElementsByTagName('script')[0];
        a.async = 1;
        a.src = 'https://nectar.ninja/api/v1/' + handle.slice(1);
        m.parentNode.insertBefore(a, m);
      })();

     

      

      

      // search box
      

      
    </script>
  </body>
</html>
